namespace AST;

public class Printer {
  public TextWriter Wr;

  private int indent = 0;
  private void IncIndent(int n = 1) => indent += n;
  private void DecIndent(int n = 1) => indent -= n;
  private void Indent() => Wr.Write(new String(' ', indent * 2));

  private string Sep = "";
  private string NextSep = "";
  private void ResetSep(string init = "", string sep = ", ") {
    Sep = init;
    NextSep = sep;
  }
  private void WriteSep() {
    Wr.Write(Sep);
    Sep = NextSep;
  }

  public Printer(TextWriter wr) {
    Wr = wr;
  }

  public static string ProgramToString(Program program) {
    StringWriter wr = new StringWriter();
    new Printer(wr).PrintProgram(program);
    return wr.ToString();
  }

  public void PrintProgram(Program program) {
    PrintTopLevelDecls(program.DefaultModuleDef.TopLevelDecls);
  }

  private void PrintTopLevelDecls(List<TopLevelDecl> topLevelDecls) {
    foreach (TopLevelDecl decl in topLevelDecls) {
      PrintTopLevelDecl(decl);
    }
  }

  private void PrintTopLevelDecl(TopLevelDecl topLevelDecl) {
    switch (topLevelDecl) {
      case ClassDecl cd:
        PrintClassDecl(cd);
        break;
      case InductiveDatatypeDecl idd:
        PrintInductiveDatatypeDecl(idd);
        break;
      default:
        throw new NotImplementedException();
    }
  }

  private void PrintClassDecl(ClassDecl cl) {
    if (cl.IsDefaultClass) {
      PrintMembers(cl.Members);
    } else {
      Indent();
      Wr.WriteLine($"class {cl.Name} {{");
      IncIndent();
      PrintMembers(cl.Members);
      DecIndent();
      Indent();
      Wr.WriteLine("}");
      Wr.WriteLine();
    }
  }

  private void PrintMembers(List<MemberDecl> mbs) {
    MemberDecl? prev = null;
    void PrintSeparator(MemberDecl? prev, MemberDecl cur) {
      if (prev is not null && cur is Method) {
        Wr.WriteLine();
      }
      // TODO: Handle other MemberDecl types
    }
    foreach (MemberDecl m in mbs) {
      PrintSeparator(prev, m);
      PrintMember(m);
      prev = m;
    }
  }

  private void PrintMember(MemberDecl mb) {
    switch (mb) {
      case Method m:
        PrintMethod(m);
        break;
      case Function f:
        PrintFunction(f);
        break;
      case Field f:
        PrintField(f);
        break;
      case DatatypeDestructor:
      case DatatypeDiscriminator:
        // Do nothing for autogenerated members.
        break;
      default:
        throw new NotImplementedException();
    }
  }

  private void PrintMethod(Method m, bool includeAutoGen = false) {
    Indent();
    string name = m is Constructor ? "constructor" : $"method";
    if (!m.IsAnonymous()) {
      name += " " + m.Name;
    }
    Wr.Write(name);
    PrintFormals(m.Ins);
    if (m.Outs.Count > 0) {
      if (m.Ins.Count + m.Outs.Count <= 3) {
        Wr.Write(" returns ");
        PrintFormals(m.Outs);
      } else {
        Wr.WriteLine();
        IncIndent();
        Indent();
        Wr.Write($"returns ");
        PrintFormals(m.Outs);
        DecIndent();
      }
    }

    IncIndent();
    PrintSpec("requires", m.Req);
    PrintFrameSpec("modifies", m.Mod);
    PrintSpec("ensures", m.Ens);
    PrintDecreasesSpec(includeAutoGen ? m.AllDecreases : m.ProvidedDecreases);
    DecIndent();

    Wr.WriteLine();
    Indent();
    PrintStatement(m.Body);
    Wr.WriteLine();
  }

  private void PrintSpec(string kind, List<AttributedExpression> aes) {
    foreach (AttributedExpression ae in aes) {
      Wr.WriteLine();
      Indent();
      Wr.Write($"{kind} ");
      PrintAttributedExpression(ae);
    }
  }

  private void PrintAttributedExpression(AttributedExpression ae) {
    PrintExpression(ae.E);
  }

  private void PrintFrameSpec(string kind, Specification<Dafny.FrameExpression, FrameExpression> frame) {
    if (frame.Expressions.Count <= 0) {
      return;
    }
    Wr.WriteLine();
    Indent();
    Wr.Write("{0} ");
    ResetSep();
    foreach (FrameExpression fe in frame.Expressions) {
      WriteSep();
      PrintExpression(fe.E);
    }
  }

  private void PrintDecreasesSpec(Specification<Dafny.Expression, Expression> decreases) {
    if (decreases.Expressions.Count <= 0) {
      return;
    }
    Wr.WriteLine();
    Indent();
    Wr.Write("decreases ");
    ResetSep();
    foreach (Expression e in decreases.Expressions) {
      WriteSep();
      PrintExpression(e);
    }
  }

  private void PrintStatement(Statement stmt) {
    if (stmt.Label != null) {
      Wr.WriteLine($"label {stmt.Label}:");
      Indent();
    }
    switch (stmt) {
      case BlockStmt blockStmt:
        Wr.WriteLine("{");
        IncIndent();
        foreach (Statement s in blockStmt.Body) {
          Indent();
          PrintStatement(s);
          Wr.WriteLine();
        }
        DecIndent();
        Indent();
        Wr.Write("}");
        break;
      case IfStmt ifStmt:
        PrintIfStmt(ifStmt);
        break;
      case ReturnStmt retStmt:
        Wr.Write("return");
        ResetSep(init: " ");
        foreach (AssignmentRhs rhs in retStmt.Rhss) {
          WriteSep();
          PrintAssignRHS(rhs);
        }
        Wr.Write(";");
        break;
      case VarDeclStmt varDeclStmt:
        PrintVarDeclStmt(varDeclStmt);
        break;
      case CallStmt callStmt:
        PrintCall(callStmt.Callee, callStmt.ArgumentBindings);
        Wr.Write(";");
        break;
      case WhileStmt whileStmt:
        PrintWhileStmt(whileStmt);
        break;
      case ForLoopStmt forLoopStmt:
        PrintForLoopStmt(forLoopStmt);
        break;
      case PrintStmt printStmt:
        PrintPrintStmt(printStmt);
        break;
      case BreakStmt breakStmt:
        PrintBreakStmt(breakStmt);
        break;
      case AssignStmt assignStmt:
        PrintAssignStmt(assignStmt);
        break;
      default:
        throw new NotSupportedException($"Unhandled printing for `{stmt.GetType()}` ");
    }
  }

  private void PrintAssignStmt(AssignStmt ass) {
    ResetSep();
    foreach (var lhs in ass.Lhss) {
      WriteSep();
      PrintExpression(lhs);
    }
    Wr.Write(" := ");
    ResetSep();
    foreach (var rhs in ass.Rhss) {
      WriteSep();
      PrintAssignRHS(rhs);
    }
    Wr.Write(";");
  }

  private void PrintCall(Expression callee, ArgumentBindings arguments) {
    PrintExpression(callee);
    PrintCallArguments(arguments);
  }

  private void PrintCallArguments(ArgumentBindings abs) {
    Wr.Write("(");
    ResetSep();
    foreach (ArgumentBinding ab in abs.ProvidedArgs) {
      WriteSep();
      if (!ab.IsPositional) {
        Wr.Write($"{ab.FormalParameterName} := ");
      }
      PrintExpression(ab.Argument);
    }
    Wr.Write(")");
  }

  private void PrintVarDeclStmt(VarDeclStmt varDecls) {
    // TODO: Handle ghost, wildcard names.
    Wr.Write("var");
    ResetSep(init: " ");
    foreach (var vd in varDecls.Decls) {
      WriteSep();
      Wr.Write(vd.Name);
      if (vd.ExplicitType != null) {
        Wr.Write(": ");
        PrintType(vd.ExplicitType);
      }
    }
    if (varDecls.HasInitialiser()) {
      // TODO: Handle other initialiser types.
      Wr.Write(" := ");
      ResetSep();
      foreach (var init in varDecls.GetDeclInitialisers()) {
        if (init is AssignmentInitialiser aInit) {
          WriteSep();
          PrintAssignRHS(aInit.Value);
        } else {
          throw new NotImplementedException($"Printing unhandled for {init.GetType()}.");
        }
      }
    }
    Wr.Write(";");
  }

  private void PrintAssignRHS(AssignmentRhs rhs) {
    switch (rhs) {
      case ExprRhs exprRhs:
        PrintExpression(exprRhs.Expr);
        break;
      case ConstructorCallRhs constructorCallRHS:
        PrintConstructorCallRhs(constructorCallRHS);
        break;
      case NewArrayRHS newArrRhs:
        PrintNewArrayRhs(newArrRhs);
        break;
      default:
        throw new NotImplementedException();
    }
  }

  // This currently only handles `new T[int size]`
  // TODO: handle `new T[EE](E)` and `new T[][EE]`
  private void PrintNewArrayRhs(NewArrayRHS nar) {
    Wr.Write("new ");
    PrintType(nar.ElementType);
    Wr.Write("[");
    ResetSep();
    foreach (Expression dim in nar.ArrayDimensions) {
      WriteSep();
      PrintExpression(dim);
    }
    Wr.Write("]");
  }

  private void PrintExpression(Expression expr) {
    switch (expr) {
      case NameSegment ns:
        Wr.Write(ns.Name);
        break;
      case BinaryExpr binExpr:
        PrintExpression(binExpr.E0);
        Wr.Write($" {BinaryExpr.OpcodeString(binExpr.Op)} ");
        PrintExpression(binExpr.E1);
        break;
      case UnaryExpr unExpr:
        Wr.Write(UnaryExpr.OpcodeString(unExpr.Op));
        PrintExpression(unExpr.E);
        break;
      case IntLiteralExpr intLitExpr:
        Wr.Write(intLitExpr.Value);
        break;
      case BoolLiteralExpr boolLitExpr:
        Wr.Write(boolLitExpr.Value ? "true" : "false");
        break;
      case StringLiteralExpr stringLitExpr:
        Wr.Write($"\"{stringLitExpr.Value}\"");
        break;
      case MapDisplayExpr mapDisplayExpr:
        PrintMapDisplayExpr(mapDisplayExpr);
        break;
      case ParensExpression parensExpr:
        // Note that this deviates from the original Dafny printer which prints 
        // parentheses optimally instead of following the program
        Wr.Write("(");
        PrintExpression(parensExpr.E);
        Wr.Write(")");
        break;
      case NegationExpression negExpr:
        // Note that this deviates from the original Dafny printer which
        // potentially prints parentheses based on binding/context strengths 
        Wr.Write("-");
        PrintExpression(negExpr.E);
        break;
      case IdentifierExpr identExpr:
        Wr.Write(identExpr.Name);
        break;
      case MemberSelectExpr memberSelectExpr:
        PrintMemberSelectExpr(memberSelectExpr);
        break;
      case StaticReceiverExpr staticReceiverExpr:
        Wr.Write(staticReceiverExpr.Type);
        break;
      case ApplySuffix applySuffix:
        PrintCall(applySuffix.Lhs, applySuffix.ArgumentBindings);
        break;
      case ITEExpr iteExpr:
        PrintITEExpr(iteExpr);
        break;
      case ChainingExpression chainingExpr:
        PrintChainingExpr(chainingExpr);
        break;
      case CollectionSelectExpr seqSelectExpr:
        PrintSeqSelectExpr(seqSelectExpr);
        break;
      case CollectionUpdateExpr collectionUpdateExpr:
        PrintCollectionUpdateExpr(collectionUpdateExpr);
        break;
      case WildcardExpr:
        Wr.Write("*");
        break;
      case ThisExpr:
        Wr.Write("this");
        break;
      case DatatypeValue datatypeValue:
        PrintDatatypeValue(datatypeValue);
        break;
      default:
        throw new NotImplementedException();
    }
  }

  private void PrintMemberSelectExpr(MemberSelectExpr mse) {
    // TODO: parentheses
    if (mse.Receiver != null && !mse.ReceiverIsImplicit) {
      PrintExpression(mse.Receiver);
      Wr.Write(".");
    }
    Wr.Write(mse.MemberName);
  }

  private void PrintFormals(List<Formal> fs) {
    Wr.Write("(");
    string sep = "";
    foreach (Formal f in fs) {
      Wr.Write(sep);
      sep = ", ";
      PrintFormal(f);
    }
    Wr.Write(")");
  }

  private void PrintFormal(Formal f) {
    Wr.Write($"{f.Name}: ");
    PrintType(f.Type);
    if (f.DefaultValue != null) {
      Wr.Write(" := ");
      PrintExpression(f.DefaultValue);
    }
  }

  private void PrintType(Type t) {
    Wr.Write(t.Name);
  }

  private void PrintFunction(Function f, bool includeAutoGen = false) {
    Indent();
    Wr.Write($"function {f.Name}");
    PrintFormals(f.Ins);
    Wr.Write(": ");
    if (f.Out != null) {
      Wr.Write("(");
      PrintFormal(f.Out);
      Wr.Write(")");
    } else {
      PrintType(f.OutType);
    }
    IncIndent();
    PrintSpec("requires", f.Req);
    PrintFrameSpec("reads", f.Reads);
    PrintSpec("ensures", f.Ens);
    PrintDecreasesSpec(includeAutoGen ? f.AllDecreases : f.ProvidedDecreases);
    DecIndent();
    Wr.WriteLine();

    if (f.Body != null) {
      Indent();
      Wr.WriteLine("{");
      IncIndent();
      Indent();
      PrintExpression(f.Body);
      Wr.WriteLine();
      DecIndent();
      Indent();
      Wr.WriteLine("}");
    }
  }

  private void PrintIfStmt(IfStmt ifStmt) {
    Wr.Write("if ");
    PrintGuard(ifStmt.Guard);
    Wr.Write(" ");
    PrintStatement(ifStmt.Thn);

    if (ifStmt.Els == null) return;
    Wr.Write(" else ");
    PrintStatement(ifStmt.Els);
  }

  private void PrintITEExpr(ITEExpr itee) {
    // TODO: parentheses?
    Wr.Write("if ");
    PrintGuard(itee.Guard);
    Wr.Write(" then ");
    PrintExpression(itee.Thn);
    Wr.Write(" else ");
    PrintExpression(itee.Els);
  }

  private void PrintGuard(Expression? g) {
    if (g == null) {
      Wr.Write("*");
    } else {
      PrintExpression(g);
    }
  }

  private void PrintWhileStmt(WhileStmt ws) {
    Wr.Write("while ");
    PrintGuard(ws.Guard);

    IncIndent();
    PrintSpec("invariant", ws.Invariants);
    PrintDecreasesSpec(ws.ProvidedDecreases);
    PrintFrameSpec("modifies", ws.Modifies);
    DecIndent();

    if (ws.Body == null) return;
    Wr.WriteLine();
    Indent();
    PrintStatement(ws.Body);
  }

  private void PrintChainingExpr(ChainingExpression ce) {
    // TODO: parentheses?
    PrintExpression(ce.Operands[0]);
    for (int i = 0; i < ce.Operators.Count; i++) {
      Wr.Write($" {BinaryExpr.OpcodeString(ce.Operators[i])} ");
      PrintExpression(ce.Operands[i + 1]);
    }
  }

  private void PrintSeqSelectExpr(CollectionSelectExpr sse) {
    // TODO: parentheses?
    PrintExpression(sse.Collection);
    Wr.Write("[");
    if (sse.Index0 != null) {
      PrintExpression(sse.Index0);
    }
    if (sse.IsSlice) {
      Wr.Write("..");
      if (sse.Index1 != null) {
        PrintExpression(sse.Index1);
      }
    }
    Wr.Write("]");
  }

  private void PrintForLoopStmt(ForLoopStmt fs) {
    Wr.Write($"for {fs.LoopIndex.Name}");
    // TODO: Handle case where type is inferred and not explicitly stated
    Wr.Write(": ");
    PrintType(fs.LoopIndex.Type);

    Wr.Write(" := ");
    PrintExpression(fs.Start);
    Wr.Write(fs.GoingUp ? " to " : " downto ");
    if (fs.End == null) {
      Wr.Write("*");
    } else {
      PrintExpression(fs.End);
    }

    IncIndent();
    PrintSpec("invariant", fs.Invariants);
    PrintDecreasesSpec(fs.ProvidedDecreases);
    PrintFrameSpec("modifies", fs.Modifies);
    DecIndent();

    Wr.WriteLine();

    if (fs.Body != null) {
      Indent();
      PrintStatement(fs.Body);
    }
  }

  private void PrintPrintStmt(PrintStmt ps) {
    Wr.Write("print ");
    ResetSep();
    foreach (var arg in ps.Args) {
      WriteSep();
      PrintExpression(arg);
    }
    Wr.Write(";");
  }

  private void PrintBreakStmt(BreakStmt bs) {
    if (bs.TargetLabel != null) {
      Wr.Write($"break {bs.TargetLabel};");
    } else {
      ResetSep(sep: " ");
      for (int i = 0; i < bs.Count; i++) {
        WriteSep();
        Wr.Write("break");
      }
      Wr.Write(";");
    }
  }

  private void PrintMapDisplayExpr(MapDisplayExpr mde) {
    Wr.Write("map");
    Wr.Write("[");
    ResetSep();
    foreach (var e in mde.Elements) {
      WriteSep();
      PrintExpression(e.Index);
      Wr.Write(" := ");
      PrintExpression(e.Value);
    }
    Wr.Write("]");
  }

  private void PrintCollectionUpdateExpr(CollectionUpdateExpr cue) {
    PrintExpression(cue.Collection);
    Wr.Write("[");
    PrintExpression(cue.Index);
    Wr.Write(" := ");
    PrintExpression(cue.Value);
    Wr.Write("]");
  }

  private void PrintInductiveDatatypeDecl(InductiveDatatypeDecl idd) {
    Indent();
    Wr.Write($"datatype {idd.Name}");
    if (idd.TypeParameters.Count > 0) {
      Wr.Write("<");
      ResetSep();
      foreach (var tp in idd.TypeParameters) {
        WriteSep();
        Wr.Write(tp.Name);
      }
      Wr.Write(">");
    }
    Wr.Write(" = ");
    ResetSep(init: "", sep: " | ");
    foreach (DatatypeConstructor c in idd.Constructors) {
      WriteSep();
      Wr.Write(c.Name);
      if (c.Formals.Count > 0) {
        PrintFormals(c.Formals);
      }
    }
    Wr.WriteLine();
    if (idd.Members.Count > 0) {
      Indent();
      Wr.WriteLine("{");
      IncIndent();
      PrintMembers(idd.Members);
      DecIndent();
      Indent();
      Wr.WriteLine("}");
    }
    Wr.WriteLine();
  }

  private void PrintDatatypeValue(DatatypeValue datatypeValue) {
    Wr.Write(datatypeValue.Constructor.Name);
    if (datatypeValue.Arguments.Count > 0) {
      Wr.Write("(");
      ResetSep();
      foreach (var a in datatypeValue.Arguments) {
        WriteSep();
        PrintExpression(a);
      }
      Wr.Write(")");
    }
  }

  private void PrintField(Field f) {
    Indent();
    Wr.Write($"var {f.Name}: ");
    PrintType(f.Type);
    Wr.WriteLine(";");
  }

  private void PrintConstructorCallRhs(ConstructorCallRhs ccr) {
    Wr.Write($"new ");
    Wr.Write(ccr.GetConstructor().Path);
    PrintCallArguments(ccr.ConstructorCall.ArgumentBindings);
  }
}