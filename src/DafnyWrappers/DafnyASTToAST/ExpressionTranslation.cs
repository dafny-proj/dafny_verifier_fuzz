using System.Numerics;
using System.Diagnostics.Contracts;
using Dafny = Microsoft.Dafny;

namespace AST.Translation;

public partial class ASTTranslator {
  private void SetType(Dafny.Expression de, Expression e) {
    e.Type = TranslateType(de.Type);
  }

  private Expression TranslateExpression(Dafny.Node n) {
    // For now, ignore differences between attributed/frame expressions 
    // and expressions.
    return n switch {
      Dafny.AttributedExpression ae => TranslateExpression(ae.E),
      Dafny.FrameExpression fe => TranslateFrameExpression(fe),
      Dafny.Expression e => TranslateExpression(e),
      _ => throw new UnsupportedTranslationException(n),
    };
  }

  private Expression TranslateExpression(Dafny.Expression e) {
    return e switch {
      Dafny.LiteralExpr le => TranslateLiteralExpr(le),
      Dafny.IdentifierExpr ie => TranslateIdentifierExpr(ie),
      Dafny.BinaryExpr be => TranslateBinaryExpr(be),
      Dafny.UnaryOpExpr ue => TranslateUnaryExpr(ue),
      Dafny.MemberSelectExpr mse => TranslateMemberSelectExpr(mse),
      Dafny.SeqSelectExpr sse => TranslateCollectionSelectExpr(sse),
      Dafny.DisplayExpression de => TranslateDisplayExpr(de),
      Dafny.MapDisplayExpr mde => TranslateMapDisplayExpr(mde),
      Dafny.SetComprehension sce => TranslateComprehensionExpr(sce),
      Dafny.MapComprehension mce => TranslateComprehensionExpr(mce),
      Dafny.SeqUpdateExpr sue => TranslateCollectionUpdateExpr(sue),
      Dafny.DatatypeValue dv => TranslateDatatypeValue(dv),
      Dafny.MultiSetFormingExpr me => TranslateMultiSetConstructionExpr(me),
      Dafny.SeqConstructionExpr se => TranslateSeqConstructionExpr(se),
      Dafny.ThisExpr te => TranslateThisExpr(te),
      Dafny.WildcardExpr we => TranslateWildcardExpr(we),
      Dafny.FunctionCallExpr fe => TranslateFunctionCallExpr(fe),
      Dafny.ITEExpr ie => TranslateITEExpr(ie),
      Dafny.LetExpr le => TranslateLetExpr(le),
      Dafny.QuantifierExpr qe => TranslateQuantifierExpr(qe),
      Dafny.NestedMatchExpr me => TranslateMatchExpr(me),
      Dafny.ApplyExpr ae => TranslateFunctionCallExpr(ae),
      Dafny.LambdaExpr le => TranslateLambdaExpr(le),
      Dafny.TypeUnaryExpr te => TranslateTypeUnaryExpr(te),
      Dafny.ConcreteSyntaxExpression cse => cse switch {
        Dafny.AutoGeneratedExpression ae => TranslateAutoGeneratedExpr(ae),
        Dafny.ParensExpression pe => TranslateParensExpr(pe),
        Dafny.DatatypeUpdateExpr de => TranslateDatatypeUpdateExpr(de),
        _ => TranslateExpression(cse.ResolvedExpression),
      },
      _ => throw new UnsupportedTranslationException(e),
    };
  }

  private Expression TranslateLiteralExpr(Dafny.LiteralExpr le) {
    if (le is Dafny.StaticReceiverExpr sre) {
      return TranslateStaticReceiverExpr(sre);
    } else if (le.Value == null) {
      return new NullLiteralExpr(TranslateType(le.Type));
    } else if (le.Value is bool b) {
      return new BoolLiteralExpr(b);
    } else if (le is Dafny.CharLiteralExpr ce) {
      return new CharLiteralExpr((string)ce.Value);
    } else if (le.Value is BigInteger i) {
      return new IntLiteralExpr(i);
    } else if (le.Value is Microsoft.BaseTypes.BigDec f) {
      return new RealLiteralExpr(f.ToDecimalString());
    } else if (le is Dafny.StringLiteralExpr se) {
      return new StringLiteralExpr((string)se.Value);
    } else {
      throw new UnsupportedTranslationException(le);
    }
  }

  private IdentifierExpr TranslateIdentifierExpr(Dafny.IdentifierExpr de) {
    return new IdentifierExpr(TranslateVariable(de.Var));
  }

  private ParensExpr TranslateParensExpr(Dafny.ParensExpression de) {
    return new ParensExpr(TranslateExpression(de.E));
  }

  private AutoGeneratedExpr TranslateAutoGeneratedExpr(Dafny.AutoGeneratedExpression de) {
    return new AutoGeneratedExpr(TranslateExpression(de.E));
  }

  private MemberSelectExpr TranslateMemberSelectExpr(Dafny.MemberSelectExpr de) {
    var e = new MemberSelectExpr(
      TranslateExpression(de.Obj), (MemberDecl)TranslateDeclRef(de.Member));
    SetType(de, e);
    return e;
  }

  private CollectionSelectExpr TranslateCollectionSelectExpr(Dafny.SeqSelectExpr de) {
    CollectionSelectExpr e;
    var collection = TranslateExpression(de.Seq);
    if (de.SelectOne) {
      e = new CollectionElementExpr(collection, TranslateExpression(de.E0));
    } else {
      e = new CollectionSliceExpr(collection,
        de.E0 == null ? null : TranslateExpression(de.E0),
        de.E1 == null ? null : TranslateExpression(de.E1));
    }
    SetType(de, e);
    return e;
  }

  private CollectionDisplayExpr<Expression>
  TranslateDisplayExpr(Dafny.DisplayExpression de) {
    var elements = de.Elements.Select(TranslateExpression);
    CollectionDisplayExpr<Expression> e = de switch {
      Dafny.SeqDisplayExpr => new SeqDisplayExpr(elements),
      Dafny.SetDisplayExpr => new SetDisplayExpr(elements),
      Dafny.MultiSetDisplayExpr => new MultiSetDisplayExpr(elements),
      _ => throw new UnsupportedTranslationException(de),
    };
    SetType(de, e);
    return e;
  }

  private MapDisplayExpr TranslateMapDisplayExpr(Dafny.MapDisplayExpr de) {
    var e = new MapDisplayExpr(de.Elements.Select(TranslateExpressionPair));
    SetType(de, e);
    return e;
  }

  private SetComprehensionExpr TranslateComprehensionExpr(Dafny.SetComprehension de) {
    var e = new SetComprehensionExpr(
      TranslateQuantifierDomain(de.BoundVars, de.Range),
      value: de.TermIsImplicit ? null : TranslateExpression(de.Term));
    SetType(de, e);
    return e;
  }

  private MapComprehensionExpr TranslateComprehensionExpr(Dafny.MapComprehension de) {
    var e = new MapComprehensionExpr(
      TranslateQuantifierDomain(de.BoundVars, de.Range),
      key: de.TermLeft == null ? null : TranslateExpression(de.TermLeft),
      value: TranslateExpression(de.Term));
    SetType(de, e);
    return e;
  }

  private CollectionUpdateExpr
  TranslateCollectionUpdateExpr(Dafny.SeqUpdateExpr de) {
    return new CollectionUpdateExpr(
      collection: TranslateExpression(de.Seq),
      index: TranslateExpression(de.Index),
      value: TranslateExpression(de.Value));
  }

  private MultiSetConstructionExpr
  TranslateMultiSetConstructionExpr(Dafny.MultiSetFormingExpr de) {
    var e = new MultiSetConstructionExpr(TranslateExpression(de.E));
    SetType(de, e);
    return e;
  }

  private SeqConstructionExpr TranslateSeqConstructionExpr(Dafny.SeqConstructionExpr de) {
    var e = new SeqConstructionExpr(
      count: TranslateExpression(de.N),
      initialiser: TranslateExpression(de.Initializer));
    SetType(de, e);
    return e;
  }

  private DatatypeValueExpr TranslateDatatypeValue(Dafny.DatatypeValue de) {
    var e = new DatatypeValueExpr(
      (DatatypeConstructorDecl)TranslateDeclRef(de.Ctor),
      de.Arguments.Select(TranslateExpression));
    SetType(de, e);
    return e;
  }

  private ThisExpr TranslateThisExpr(Dafny.ThisExpr de) {
    var type = TranslateType(de.Type);
    if (de is Dafny.ImplicitThisExpr) {
      return new ImplicitThisExpr(type);
    }
    return new ThisExpr(type);
  }

  private WildcardExpr TranslateWildcardExpr(Dafny.WildcardExpr de) {
    return new WildcardExpr();
  }

  private FunctionCallExpr TranslateFunctionCallExpr(Dafny.FunctionCallExpr de) {
    var e = new FunctionCallExpr(
      callee: new MemberSelectExpr(
        TranslateExpression(de.Receiver),
        (FunctionDecl)TranslateDeclRef(de.Function)),
      arguments: de.Args.Select(TranslateExpression));
    SetType(de, e);
    return e;
  }

  private FunctionCallExpr TranslateFunctionCallExpr(Dafny.ApplyExpr de) {
    return new FunctionCallExpr(
      callee: TranslateExpression(de.Function),
      arguments: de.Args.Select(TranslateExpression));
  }

  private StaticReceiverExpr TranslateStaticReceiverExpr(Dafny.StaticReceiverExpr de) {
    Contract.Assert(de.Type is Dafny.UserDefinedType);
    var d = (TopLevelDecl)TranslateDeclRef(((Dafny.UserDefinedType)de.Type).ResolvedClass);
    if (de.IsImplicit) {
      return new ImplicitStaticReceiverExpr(d);
    }
    return new StaticReceiverExpr(d);
  }

  private ITEExpr TranslateITEExpr(Dafny.ITEExpr de) {
    var e = new ITEExpr(TranslateExpression(de.Test),
      TranslateExpression(de.Thn), TranslateExpression(de.Els));
    SetType(de, e);
    return e;
  }

  private LetExpr TranslateLetExpr(Dafny.LetExpr de) {
    var vars = new List<VarExpressionPair>();
    foreach (var (l, r) in de.BoundVars.Zip(de.RHSs)) {
      vars.Add(
        new VarExpressionPair(TranslateBoundVar(l), TranslateExpression(r)));
    }
    var e = new LetExpr(vars, TranslateExpression(de.Body));
    SetType(de, e);
    return e;
  }

  private QuantifierExpr TranslateQuantifierExpr(Dafny.QuantifierExpr de) {
    var qd = TranslateQuantifierDomain(de.BoundVars, de.Range);
    var term = TranslateExpression(de.Term);
    if (de is Dafny.ForallExpr) {
      return new ForallExpr(qd, term);
    } else if (de is Dafny.ExistsExpr) {
      return new ExistsExpr(qd, term);
    } else {
      throw new UnsupportedTranslationException(de);
    }
  }

  private MatchExpr TranslateMatchExpr(Dafny.NestedMatchExpr de) {
    var selector = TranslateExpression(de.Source);
    var cases = new List<MatchExprCase>();
    foreach (var c in de.Cases) {
      var body = TranslateExpression(c.Body);
      var matcher = TranslateMatcher(c.Pat);
      cases.Add(new MatchExprCase(matcher, body));
    }
    var e = new MatchExpr(selector, cases);
    SetType(de, e);
    return e;
  }

  private LambdaExpr TranslateLambdaExpr(Dafny.LambdaExpr de) {
    var params_ = de.BoundVars.Select(TranslateBoundVar);
    var result = TranslateExpression(de.Body);
    var pre = de.Range == null ? null :
      new Specification(Specification.Type.Precondition,
      new[] { TranslateExpression(de.Range) });
    var reads = TranslateSpecification(Specification.Type.ReadFrame, de.Reads);
    var e = new LambdaExpr(params_, result, pre, reads);
    SetType(de, e);
    return e;
  }

  private DatatypeUpdateExpr TranslateDatatypeUpdateExpr(Dafny.DatatypeUpdateExpr de) {
    Contract.Assert(de.Updates.Count == de.Members.Count());
    Contract.Assert(de.Members.TrueForAll(m => m is Dafny.DatatypeDestructor));
    var datatypeValue = TranslateExpression(de.Root);
    var updates = new List<DatatypeUpdatePair>(de.Updates.Count);
    foreach (var (m, u) in de.Members.Zip(de.Updates)) {
      var id = (DatatypeDestructorDecl)TranslateDeclRef(m);
      var value = TranslateExpression(u.Item3);
      updates.Add(new DatatypeUpdatePair(id, value));
    }
    return new DatatypeUpdateExpr(datatypeValue, updates);
  }

  private TypeUnaryExpr TranslateTypeUnaryExpr(Dafny.TypeUnaryExpr de) {
    var ee = TranslateExpression(de.E);
    var t = TranslateType(de.ToType);
    TypeUnaryExpr e = de switch {
      Dafny.ConversionExpr => new TypeConversionExpr(ee, t),
      Dafny.TypeTestExpr => new TypeCheckExpr(ee, t),
      _ => throw new UnsupportedTranslationException(de),
    };
    SetType(de, e);
    return e;
  }

  private Expression TranslateFrameExpression(Dafny.FrameExpression de) {
    var e = TranslateExpression(de.E);
    if (de.Field != null) {
      e = new FrameFieldExpr(e, (FieldDecl)TranslateDeclRef(de.Field));
    }
    return e;
  }

  private BinaryExpr TranslateBinaryExpr(Dafny.BinaryExpr de) {
    return new BinaryExpr(TranslateBinaryOpcode(de.Op),
      TranslateExpression(de.E0), TranslateExpression(de.E1));
  }

  private BinaryExpr.Opcode TranslateBinaryOpcode(Dafny.BinaryExpr.Opcode op) {
    return op switch {
      Dafny.BinaryExpr.Opcode.Iff => BinaryExpr.Opcode.Iff,
      Dafny.BinaryExpr.Opcode.Imp => BinaryExpr.Opcode.Imp,
      Dafny.BinaryExpr.Opcode.Exp => BinaryExpr.Opcode.Exp,
      Dafny.BinaryExpr.Opcode.And => BinaryExpr.Opcode.And,
      Dafny.BinaryExpr.Opcode.Or => BinaryExpr.Opcode.Or,
      Dafny.BinaryExpr.Opcode.Eq => BinaryExpr.Opcode.Eq,
      Dafny.BinaryExpr.Opcode.Neq => BinaryExpr.Opcode.Neq,
      Dafny.BinaryExpr.Opcode.Lt => BinaryExpr.Opcode.Lt,
      Dafny.BinaryExpr.Opcode.Le => BinaryExpr.Opcode.Le,
      Dafny.BinaryExpr.Opcode.Ge => BinaryExpr.Opcode.Ge,
      Dafny.BinaryExpr.Opcode.Gt => BinaryExpr.Opcode.Gt,
      Dafny.BinaryExpr.Opcode.Disjoint => BinaryExpr.Opcode.Disjoint,
      Dafny.BinaryExpr.Opcode.In => BinaryExpr.Opcode.In,
      Dafny.BinaryExpr.Opcode.NotIn => BinaryExpr.Opcode.NotIn,
      Dafny.BinaryExpr.Opcode.LeftShift => BinaryExpr.Opcode.LeftShift,
      Dafny.BinaryExpr.Opcode.RightShift => BinaryExpr.Opcode.RightShift,
      Dafny.BinaryExpr.Opcode.Add => BinaryExpr.Opcode.Add,
      Dafny.BinaryExpr.Opcode.Sub => BinaryExpr.Opcode.Sub,
      Dafny.BinaryExpr.Opcode.Mul => BinaryExpr.Opcode.Mul,
      Dafny.BinaryExpr.Opcode.Div => BinaryExpr.Opcode.Div,
      Dafny.BinaryExpr.Opcode.Mod => BinaryExpr.Opcode.Mod,
      Dafny.BinaryExpr.Opcode.BitwiseAnd => BinaryExpr.Opcode.BitwiseAnd,
      Dafny.BinaryExpr.Opcode.BitwiseOr => BinaryExpr.Opcode.BitwiseOr,
      Dafny.BinaryExpr.Opcode.BitwiseXor => BinaryExpr.Opcode.BitwiseXor,
      _ => throw new UnsupportedTranslationException(op),
    };
  }

  private UnaryExpr TranslateUnaryExpr(Dafny.UnaryOpExpr de) {
    return new UnaryExpr(
      TranslateUnaryOpcode(de.Op), TranslateExpression(de.E));
  }

  private UnaryExpr.Opcode TranslateUnaryOpcode(Dafny.UnaryOpExpr.Opcode op) {
    return op switch {
      Dafny.UnaryOpExpr.Opcode.Not => UnaryExpr.Opcode.Not,
      Dafny.UnaryOpExpr.Opcode.Cardinality => UnaryExpr.Opcode.Cardinality,
      Dafny.UnaryOpExpr.Opcode.Fresh => UnaryExpr.Opcode.Fresh,
      Dafny.UnaryOpExpr.Opcode.Allocated => UnaryExpr.Opcode.Allocated,
      _ => throw new UnsupportedTranslationException(op),
    };
  }

}
